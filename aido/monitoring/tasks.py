import os
import json
import shlex
import inspect
import shutil
import tempfile
import subprocess
import numpy as np
import pandas as pd
import importlib.util
from enum import Enum
from typing import Optional

from aido.monitoring.logger import WandbTaskLogger
from aido.monitoring.client import WandbTaskLoggerClient

class TaskType(Enum):
    RECONSTRUCTION = 0

class WandbSubprocessWrapper:
    def __init__(self, command: str, subprocess_logger: Optional[WandbTaskLogger] = None,
                 patch_client: bool = False, raise_on_error: bool = False):
        """Wrapper to run a subprocess command and log its monitoring output.
        Args:
            command (str): The command to run as a subprocess.
            subprocess_logger (Optional[WandbTaskLogger]): WandbTaskLogger to log monitoring data.
        """
        self.command = command
        self.patch_client = patch_client
        self.raise_on_error = raise_on_error
        self.subprocess_logger = subprocess_logger

    def __enter__(self):
        return self
    
    def __exit__(self, exc_type, exc_value, traceback):
        if self.patch_root is not None:
            shutil.rmtree(self.patch_root)

    def run(self, *args):
        patch_args = []
        container_type = None
        command_list = shlex.split(self.command)

        if len(command_list) > 0:
            if command_list[0] == 'docker':
                container_type = 'docker'
            elif command_list[0] == 'singularity':
                container_type = 'singularity'

        if self.patch_client and container_type is not None:
            patch_args = self._patch_wandb_logger_client(container_type=container_type or 'singularity')

        if patch_args:
            for idx, token in enumerate(command_list):
                if token in ('exec', 'run'):
                    insert_idx = idx + 1
                    break
            else:
                insert_idx = 0
            command_list = command_list[:insert_idx] + patch_args + command_list[insert_idx:]

        command_list.extend(map(str, args))
        full_command = shlex.join(command_list)

        if self.subprocess_logger is not None:
            proc = subprocess.Popen(full_command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
            for line in proc.stdout:
                line = line.strip()
                if not line:
                    continue
                try:
                    msg = json.loads(line)
                    self._process_monitoring_message(msg)
                except json.JSONDecodeError as e:
                    print(line)
                except Exception as e:
                    if self.raise_on_error:
                        raise Exception(f"Exception: {line.strip()} ({e})")
                    raise e
            proc.wait()
            if proc.returncode != 0:
                err = proc.stderr.read()
                print(f"[WandbSubprocessWrapper] Subprocess exited with code {proc.returncode}.")
                if err:
                    print(f"[WandbSubprocessWrapper] Subprocess stderr:\n{err}")
        else:
            os.system(full_command)

    def _patch_wandb_logger_client(self, container_type: str = "singularity") -> list[str]:
        """Patch the WandbTaskLoggerClient inside the container by creating a temporary 
        directory with the module code. Requires that WandbTaskLoggerClient reqzuires no 
        additional dependencies beyond the standard library."""

        self.patch_root = tempfile.mkdtemp(prefix="aido_patches_")
        module_path = WandbTaskLoggerClient.__module__
        parts = module_path.split(".")
        dir_path = os.path.join(self.patch_root, *parts[:-1])
        os.makedirs(dir_path, exist_ok=True)

        spec = importlib.util.find_spec(module_path)
        if spec is None or not spec.origin:
            raise RuntimeError(f"Could not find source file for module {module_path}")
        with open(spec.origin, "r") as src, open(os.path.join(dir_path, f"{parts[-1]}.py"), "w") as dst:
            dst.write(src.read())

        for i in range(1, len(parts)):
            p = os.path.join(self.patch_root, *parts[:i])
            init_file = os.path.join(p, "__init__.py")
            if not os.path.exists(init_file):
                with open(init_file, "w") as f:
                    f.write("# autogenerated __init__.py\n")

        if container_type == "docker":
            args = ["-v", f"{self.patch_root}:/patches",
                    "-e", "PYTHONPATH=/patches"]
        elif container_type == "singularity":
            args = ["-B", f"{self.patch_root}:/patches",
                    "--env", "PYTHONPATH=/patches"]
        else:
            raise ValueError(f"Unknown container_type: {container_type}")
        return args


    def _process_monitoring_message(self, msg):
        if self.subprocess_logger is None:
            return

        if msg.get("type") == "scalars":
            key = msg.get("key", "scalars")
            scalars = msg.get("scalars", [])
            step_offset = msg.get("step_offset", None)
            self.subprocess_logger.log_scalars(key, scalars, step_offset)
